"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageManger = void 0;
exports.init = init;
exports.createPackageManager = createPackageManager;
const path_1 = __importDefault(require("path"));
const log_1 = require("./log");
const account_1 = require("./account");
const package_content_1 = require("./rest-api/package-content");
const zip_1 = require("./zip");
const package_dependecy_1 = require("./rest-api/package-dependecy");
const package_description_1 = require("./rest-api/package-description");
const dasha_packages_1 = require("./json/generated/dasha-packages");
const node_fs_wrapper_1 = require("./file-system/node-fs-wrapper");
const models = __importStar(require("./rest-api/generated/core/models"));
const fs_1 = require("fs");
const errors = __importStar(require("./errors"));
const errors_1 = require("./file-system/errors");
async function init(type, directory) {
    if (!Object.values(models.PackageContentType).includes(type)) {
        throw new errors.ArgumentError(`Unknown package type '${type}'. Available types: ${JSON.stringify(Object.values(models.PackageContentType))}`);
    }
    const isDirectoryExists = await fs_1.promises
        .lstat(directory)
        .then((stat) => {
        return stat.isDirectory();
    })
        .catch((e) => {
        throw new errors_1.PathNotExistsError(directory, e);
    });
    if (!isDirectoryExists) {
        throw new errors.ArgumentError(`'${directory}' is not a directory.`);
    }
    const packageConfigPath = path_1.default.join(directory, "dasha-packages.json");
    const isPackageConfigExists = await fs_1.promises
        .lstat(packageConfigPath)
        .then((stat) => {
        return stat.isFile();
    })
        .catch((e) => {
        return false;
    });
    if (isPackageConfigExists) {
        throw new errors.ArgumentError(`Specified directory already contains file 'dasha-packages.json'.`);
    }
    const packageConfig = {
        type,
        dependencies: {},
        locks: {},
    };
    await fs_1.promises.writeFile(packageConfigPath, JSON.stringify(packageConfig, null, 2));
}
class PackageManger {
    constructor(account, log, fs) {
        this._log = log;
        this._fs = fs;
        this._account = account;
        this._contentApi = new package_content_1.PackageContentApi(this._account, this._log);
        this._resolverApi = new package_dependecy_1.PackageDependencyResolverApi(this._account, this._log);
        this._descriptionApi = new package_description_1.PackageDescriptionApi(this._account, this._log);
    }
    async restoreDependecy(options) {
        const projectInfo = await this.prepareInformation(options);
        await this.restoreDependecyInternal(projectInfo, { force: options.force });
    }
    async restoreDependecyInternal(projectInfo, options) {
        var _a;
        // resolve packages into package lock
        const resolvedPackages = await this._resolverApi.resolve(projectInfo.content.dependencies);
        projectInfo.content.locks = resolvedPackages.dependenciesLock;
        await this.downloadPackages(projectInfo.content.locks, {
            realStoragePath: projectInfo.realStoragePath,
            storagePath: projectInfo.storagePath,
            force: (_a = options.force) !== null && _a !== void 0 ? _a : false
        });
        await this._fs.writeFile(projectInfo.path, JSON.stringify(projectInfo.content, null, 2));
        this._log.info("Dependecies lock updated successfully");
    }
    //restriction == only while backend not support another
    async addDependency(name, version, restriction, options) {
        const projectInfo = await this.prepareInformation(options);
        this._log.info(`Checking existance of package with name '${name}'`);
        await this._descriptionApi.getDescription(name);
        this._log.info(`Package with name '${name}' exist`);
        projectInfo.content.dependencies[name] = restriction + version;
        this._log.info(`Restoring dependency '${name}'`);
        await this.restoreDependecyInternal(projectInfo, { force: false });
        this._log.info("Dependecy add successfully");
    }
    async removeDependency(name, options) {
        var _a, _b;
        const projectInfo = await this.prepareInformation(options);
        this._log.info(`Removing dependency '${name}'`);
        if (((_a = projectInfo.content.locks) === null || _a === void 0 ? void 0 : _a[name]) !== undefined) {
            const pathsInformation = this.getPathsInformation(name, projectInfo.content.locks[name], {
                realStoragePath: projectInfo.realStoragePath,
                storagePath: projectInfo.storagePath
            });
            await this._fs.rmLogged(this.getPackageRootDirectory(pathsInformation), { recursive: true });
        }
        delete projectInfo.content.dependencies[name];
        if (projectInfo.content.locks !== undefined) {
            delete projectInfo.content.locks[name];
        }
        await this.restoreDependecyInternal(projectInfo, { force: false });
        if (((_b = projectInfo.content) === null || _b === void 0 ? void 0 : _b.locks) !== undefined &&
            projectInfo.content.locks[name] !== undefined) {
            this._log.info(`Dependecy ${name} cannot be removed full because some another package have it as dependecy`);
            return;
        }
        this._log.info("Dependecy removed successfully");
    }
    async findPackageFile(directory) {
        var _a;
        const resolvedPath = path_1.default.resolve(directory, `.${path_1.default.sep}/dasha-packages.json`);
        const packageFile = await this._fs.stat(resolvedPath);
        if (packageFile === undefined)
            throw new Error(`No 'dasha-packages.json' file was detected in path '${directory}'`);
        if (!packageFile.isFile)
            throw new Error(`'dasha-packages.json' not a file in path '${directory}'`);
        let config;
        try {
            config = JSON.parse(await this._fs.readFile(resolvedPath, { encoding: "utf8" }));
        }
        catch (e) {
            throw new Error(`Could not parse 'dasha-packages.json' file: ${e.message}`);
        }
        if (!dasha_packages_1.DashaPackages.validate(config)) {
            throw new Error((_a = dasha_packages_1.DashaPackages.validate.errors) === null || _a === void 0 ? void 0 : _a.join("\n"));
        }
        return {
            filepath: resolvedPath,
            content: config
        };
    }
    async prepareInformation(options) {
        var _a;
        // determinate dasha-packages
        const packageFile = await this.findPackageFile(options.directoryPath);
        const packageFileDir = path_1.default.dirname(packageFile.filepath);
        // construct path for dasha-packages
        const packageStoragePath = path_1.default.resolve(packageFileDir, (_a = packageFile.content.packagesFolderPath) !== null && _a !== void 0 ? _a : `.${path_1.default.sep}dasha-packages`);
        const defaultDirectory = await this.getDefaultPackageDirectory();
        return {
            realStoragePath: packageStoragePath,
            storagePath: this._fs.canUseSymLink ? defaultDirectory : packageStoragePath,
            content: packageFile.content,
            path: packageFile.filepath,
        };
    }
    async getDefaultPackageDirectory() {
        var _a, _b;
        const envPaths = await Promise.resolve().then(() => __importStar(require("env-paths"))).catch(() => null);
        if (envPaths) {
            const configDir = envPaths.default("dasha.ai", { suffix: "" }).config;
            return (_a = process.env.DASHA_PACKAGE_CACHE_PATH) !== null && _a !== void 0 ? _a : path_1.default.resolve(configDir, `.${path_1.default.sep}dasha-packages`);
        }
        return (_b = process.env.DASHA_PACKAGE_CACHE_PATH) !== null && _b !== void 0 ? _b : `.${path_1.default.sep}dasha-packages`;
    }
    async downloadPackages(lockDescriptions, options) {
        this._log.info(`Downloading packages`);
        const relativePackagesPaths = Object.entries(lockDescriptions)
            .map(([name, lockDescription]) => this.getPathsInformation(name, lockDescription, options));
        for (const packagePaths of relativePackagesPaths) {
            if (options.force || await this.isNeedDownloadPackage(packagePaths.storePath)) {
                this._log.debug(`Selected to download package '${packagePaths.name}'`);
                await this.preparePackageDestanation(packagePaths);
                await this.downloadPackageInternal(packagePaths);
                continue;
            }
            this._log.warn(`Directory for package '${packagePaths.name}' exists and there is no guarantee that the package inside is valid`);
        }
        for (const packagePath of relativePackagesPaths.filter(paths => paths.storePath !== paths.realPath)) {
            await this.prepareSymbolLinkDestanation(packagePath);
            await this.createSymbolLink(packagePath);
        }
        this._log.info(`Packages downloaded`);
    }
    getPathsInformation(name, lockDescription, options) {
        const relativePath = `.${path_1.default.sep}` + [name, lockDescription.version, lockDescription.packageContentId].join(path_1.default.sep);
        const storePath = path_1.default.resolve(options.storagePath, relativePath);
        const realPath = path_1.default.resolve(options.realStoragePath, relativePath);
        return {
            name: name,
            lockDescription: lockDescription,
            storePath: storePath,
            realPath: realPath,
        };
    }
    async downloadPackageInternal(description) {
        this._log.silly(`Downloading '${description.name}:${description.lockDescription.version}'`);
        const downloadedZip = await this._contentApi.getContentById(description.lockDescription.packageContentId);
        this._log.debug(`Downloaded '${description.name}:${description.lockDescription.version}'`);
        this._log.silly(`Unpacking '${description.name}:${description.lockDescription.version}' into '${description.storePath}'`);
        await (0, zip_1.unzip)(description.storePath, downloadedZip.content, this._fs);
        this._log.debug(`Unpacked '${description.name}:${description.lockDescription.version}' into '${description.storePath}'`);
    }
    async preparePackageDestanation(description) {
        await this._fs.rmLogged(description.storePath, { recursive: true });
        await this._fs.mkdirLogged(description.storePath, { recursive: true });
    }
    async prepareSymbolLinkDestanation(description) {
        // try remove existing directory in dasha-packages directory
        await this._fs.rmLogged(this.getPackageRootDirectory(description), { recursive: true });
        // create directory for package in dasha-packages directory
        await this._fs.mkdirLogged(path_1.default.resolve(description.realPath, ".."), { recursive: true });
    }
    async createSymbolLink(description) {
        this._log.silly(`Creating a symbolic link from "${description.storePath}" to "${description.realPath}"`);
        await this._fs.symlink(description.storePath, description.realPath);
        this._log.debug(`Created symbolic link from '${description.storePath}' to '${description.realPath}'`);
    }
    async isNeedDownloadPackage(packagePath) {
        var _a;
        // if directory on path not exist or is not directory or directory is empty, then download
        const skipCondition = ((_a = (await this._fs.stat(packagePath))) === null || _a === void 0 ? void 0 : _a.isDirectory) === true &&
            await this._fs.dirlength(packagePath) !== 0;
        return !skipCondition;
    }
    getPackageRootDirectory(packagePaths) {
        // realpath = ./packagename/packageversion/packagecontentId
        // resolved = ./packagename/packageversion/packagecontentId/../.. -> ./packagename
        return path_1.default.resolve(packagePaths.realPath, `..${path_1.default.sep}..`);
    }
}
exports.PackageManger = PackageManger;
async function createPackageManager(options) {
    var _a;
    const account = (_a = options === null || options === void 0 ? void 0 : options.account) !== null && _a !== void 0 ? _a : (await (0, account_1._getEffectiveAccount)({ _log: log_1.log }));
    const log = log_1.log.child({ account: (0, account_1.anonymizeAccount)(account) });
    return new PackageManger(account, log, new node_fs_wrapper_1.NodeFsWrapper(log));
}
//# sourceMappingURL=package-manager.js.map