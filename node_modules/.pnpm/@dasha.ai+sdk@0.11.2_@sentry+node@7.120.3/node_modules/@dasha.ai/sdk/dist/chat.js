"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleChat = exports.Chat = exports.ChatConnection = void 0;
exports.connect = connect;
exports.createChat = createChat;
exports.createConsoleChat = createConsoleChat;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const errors = __importStar(require("./errors"));
const grpc = __importStar(require("./grpc-api"));
const account_1 = require("./account");
const log_1 = require("./log");
/** @internal */
class ChatConnection {
    /** @internal */
    constructor(chat) {
        /** @internal */ this._sessionConfig = { type: "text" };
        this._chat = chat;
    }
    /** @internal */ _init(jobId) {
        this._chat._init(jobId);
    }
}
exports.ChatConnection = ChatConnection;
/**
 * Connect the application to a {@link Chat} instance.
 *
 * @see ConnectionProvider
 *
 * @deprecated use the `channel` parameter to {@link Conversation.execute} instead
 */
function connect(chat) {
    return new ChatConnection(chat);
}
async function createChat(accountOrConversation, options) {
    var _a;
    if (accountOrConversation === undefined || "apiKey" in accountOrConversation) {
        const account = accountOrConversation;
        return new Chat(account !== null && account !== void 0 ? account : (await (0, account_1._getEffectiveAccount)({ _log: log_1.log })));
    }
    const conversation = accountOrConversation;
    return new Chat((_a = options === null || options === void 0 ? void 0 : options.account) !== null && _a !== void 0 ? _a : (await (0, account_1._getEffectiveAccount)({ _log: log_1.log })), conversation);
}
/**
 * A text-based means of communication with an {@link Application}.
 */
class Chat extends eventemitter3_1.default {
    /**
     * Create a {@link Chat} instance to use with an application.
     *
     * @param account Dasha account to use. Must be the same as the application's account.
     */
    constructor(account, conversation) {
        super();
        this.account = account;
        this._closed = false;
        this._internalEvents = new eventemitter3_1.default();
        this._handleText = (_jobId, text) => {
            this.emit("text", text);
            if (text !== "") {
                this._gluedText = this._gluedText + text + "\n";
            }
        };
        this._handleClose = () => {
            this._closed = true;
            this._handleWait();
            this.emit("close");
        };
        this._handleError = (error) => {
            this._closed = true;
            this._handleWait();
            this.emit("error", error);
        };
        this._handleWait = () => {
            this.emit("gluedText", this._gluedText.trimEnd());
            this._gluedText = "";
        };
        this._gluedText = "";
        this._openWaiter = new Promise((resolve, reject) => {
            if (conversation == undefined) {
                resolve();
                return;
            }
            const timeout = setTimeout(() => reject(new Error("Time out waiting start")), 5 * 1000 * 60);
            conversation.once("debugLog", async () => {
                try {
                    await this._init(conversation._jobId);
                }
                catch (e) {
                    clearTimeout(timeout);
                    reject(e);
                    throw e;
                }
                clearTimeout(timeout);
                resolve();
            });
        });
    }
    /** @internal */
    async _init(jobId) {
        this._jobId = jobId;
        this._textProtocolClient = await grpc.createTextProtocolClient(this.account, log_1.log);
        this._messageStream = this._textProtocolClient.messageStream({ jobId });
        this._messageStream.on("error", this._handleError);
        this._messageStream.on("text", this._handleText);
        this._messageStream.on("close", this._handleClose);
        this._messageStream.on("wait", this._handleWait);
    }
    /**
     * Send some text to the application.
     */
    async sendText(text) {
        if (this._closed) {
            log_1.log.warn(`Trying to send message '${text}' for closed conversation '${this._jobId}'`);
            return;
        }
        await this._openWaiter;
        await this._textProtocolClient.sendText({ jobId: this._jobId, text });
    }
    /**
     * Send some text and wait for response
     */
    async sendTextAndReceiveResponse(text) {
        if (this._closed) {
            log_1.log.warn(`Trying to send message '${text}' for closed conversation '${this._jobId}'`);
            return "";
        }
        await this._openWaiter;
        this._internalEvents.emit("sendTextAndReceiveResponseCalled");
        const gluedPromise = new Promise((resolve, reject) => {
            this.once("gluedText", (text) => resolve(text));
            this._internalEvents.once("sendTextAndReceiveResponseCalled", () => resolve(""));
        });
        await this._textProtocolClient.sendText({ jobId: this._jobId, text });
        return await gluedPromise;
    }
    /**
     * Close the chat, notifying the application.
     */
    async close() {
        if (this._closed) {
            return;
        }
        await this._openWaiter;
        await this._textProtocolClient.sendClose({ jobId: this._jobId });
        this._closed = true;
    }
}
exports.Chat = Chat;
async function createConsoleChat(accountOrConversation, options) {
    var _a, _b;
    if (accountOrConversation === undefined || "apiKey" in accountOrConversation) {
        const account = accountOrConversation;
        return new ConsoleChat(account !== null && account !== void 0 ? account : (await (0, account_1._getEffectiveAccount)({ _log: log_1.log })), undefined, (_a = options === null || options === void 0 ? void 0 : options.syncMode) !== null && _a !== void 0 ? _a : false);
    }
    const conversation = accountOrConversation;
    return new ConsoleChat((_b = options === null || options === void 0 ? void 0 : options.account) !== null && _b !== void 0 ? _b : (await (0, account_1._getEffectiveAccount)({ _log: log_1.log })), conversation, options === null || options === void 0 ? void 0 : options.syncMode);
}
/**
 * A simple, console-based {@link Chat} wrapper for testing and debugging applications.
 * Only available in Node.js.
 */
class ConsoleChat extends Chat {
    constructor(account, conversation, syncMode) {
        super(account, conversation);
        this.log = log_1.log.child({ label: "console-chat" });
        this._syncMode = syncMode !== null && syncMode !== void 0 ? syncMode : false;
    }
    /** @internal */
    async _init(jobId) {
        const readline = await Promise.resolve().then(() => __importStar(require("readline"))).catch(() => {
            (0, log_1.logAndThrow)(this.log, new errors.NotImplementedError("ConsoleChat only available in node.js"));
        });
        await super._init(jobId);
        this._interface = readline.createInterface(process.stdin);
        this._interface.on("line", (text) => {
            if (this._syncMode) {
                this.sendTextAndReceiveResponse(text).catch((error) => this.emit("error", error));
            }
            else {
                this.sendText(text).catch((error) => this.emit("error", error));
            }
        });
        console.log("chat started");
        if (this._syncMode) {
            this.on("gluedText", (text) => {
                if (text !== "") {
                    console.log(`AI: ${text}`);
                }
            });
        }
        else {
            this.on("text", (text) => console.log(`AI: ${text}`));
        }
        this.on("close", () => this._interface.close());
    }
}
exports.ConsoleChat = ConsoleChat;
//# sourceMappingURL=chat.js.map