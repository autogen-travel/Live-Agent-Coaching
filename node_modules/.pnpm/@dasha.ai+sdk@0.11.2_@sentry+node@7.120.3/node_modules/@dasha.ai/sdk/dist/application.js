"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = void 0;
const assert_1 = __importDefault(require("assert"));
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const axios_1 = __importStar(require("axios"));
const audio = __importStar(require("./audio"));
const errors = __importStar(require("./errors"));
const grpc = __importStar(require("./grpc-api"));
const rest = __importStar(require("./rest-api"));
const stt = __importStar(require("./stt"));
const tts = __importStar(require("./tts"));
const zip = __importStar(require("./zip"));
const account_1 = require("./account");
const conversation_1 = require("./conversation");
const log_1 = require("./log");
const queue_1 = require("./queue");
const sdk_observer_1 = require("./sdk-observer");
// we can not import it in ts-style because the package is not into TS rootDir
// if you know
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require("../package.json");
const sdkVersion = `node:${(_a = packageJson.name) !== null && _a !== void 0 ? _a : "unknown"}@${(_b = packageJson.version) !== null && _b !== void 0 ? _b : "unknown"}`;
/** @todo check sdkObserver optionality */
var ApplicationState;
(function (ApplicationState) {
    ApplicationState[ApplicationState["Initial"] = 0] = "Initial";
    ApplicationState[ApplicationState["Stopping"] = 1] = "Stopping";
    ApplicationState[ApplicationState["Stopped"] = 2] = "Stopped";
    ApplicationState[ApplicationState["Running"] = 3] = "Running";
})(ApplicationState || (ApplicationState = {}));
// reference-style links don't seem to work here, for whatever reason
/**
 * A [DashaScript](https://docs.dasha.ai/en-us/default/dasha-script-language/)
 * conversational application {@link deploy | deployed} to the Dasha platform.
 *
 * @template TInput conversation input data type
 * @template TOutput conversation output data type
 */
class Application extends eventemitter3_1.default {
    /** @internal */
    static async _deploy(options) {
        const processingClient = await grpc.createProcessingClient(options.account, options.log);
        const externalTtsClient = await grpc.createExternalTtsClient(options.account, options.log);
        const instanceStream = processingClient.registerInstanceStream({
            ...options,
            concurrency: 0,
            sdkVersion: sdkVersion,
        });
        return new Promise((resolve, reject) => {
            var _a;
            (_a = options.cancelToken) === null || _a === void 0 ? void 0 : _a._onCancel(options.log, (error) => {
                instanceStream.cancel();
                reject(error);
            });
            instanceStream.on("progress", ({ scopes, description, percent, severity }) => {
                options.log.log(severity, `${scopes.join(": ")}: ${description} ${percent}%`);
            });
            if (options.onProgress !== undefined) {
                instanceStream.on("progress", options.onProgress);
            }
            instanceStream.on("error", (error) => {
                instanceStream.cancel();
                processingClient.close();
                reject(error);
            });
            instanceStream.on("success", (applicationId, instanceId, applicationName, inputSchema, outputSchema) => {
                var _a;
                options.log.info("application deployed");
                instanceStream.removeAllListeners();
                const application = new Application(options, applicationId, applicationName, instanceId, processingClient, externalTtsClient, instanceStream, inputSchema, outputSchema);
                // SdkObserver is not available in websdk
                (_a = sdk_observer_1.SdkObserver === null || sdk_observer_1.SdkObserver === void 0 ? void 0 : sdk_observer_1.SdkObserver.shared) === null || _a === void 0 ? void 0 : _a._registerApplication(application);
                resolve(application);
            });
        });
    }
    constructor(options, applicationId, applicationName, instanceId, processingClient, externalTtsClient, instanceStream, inputSchema, outputSchema) {
        super();
        this._audioClientStreams = [];
        //#region lifecycle
        this._state = ApplicationState.Initial;
        this._concurrency = 0;
        //#endregion
        //#region stream reconnects
        this._healthcheckInProgress = false;
        this._healthcheck = async () => {
            try {
                if (this._healthcheckInProgress) {
                    return;
                }
                this._healthcheckInProgress = true;
                await this._healthcheckInternal();
            }
            finally {
                this._healthcheckInProgress = false;
            }
        };
        this._healthcheckInternal = async () => {
            const isHealthy = await this.healthCheck();
            this.emit("health", isHealthy);
            if (!isHealthy) {
                this.log.warn(`healthcheck found connection issues; trying to reconnect`);
                if (this._healthcheckIntervalHandle) {
                    clearInterval(this._healthcheckIntervalHandle);
                    this._healthcheckIntervalHandle = undefined;
                }
                await this._reconnect();
            }
        };
        this._handleStreamError = async (error) => {
            await this._reconnect(error);
        };
        this.reconnectInProgress = false;
        //#endregion
        //#region external call handlers
        // cannot type better because of variance problems
        // eslint-disable-next-line @typescript-eslint/ban-types
        this._externals = new Map();
        this._handleRpcRequest = async (request) => {
            const { jobId, requestId, method, parameters } = request;
            if (this._state === ApplicationState.Initial || this._state === ApplicationState.Stopped) {
                this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.Error("application is not running")));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: "application instance was not running" },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            const conv = this._activeConversationsByJobId.get(jobId);
            if (conv === undefined) {
                this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.InternalError()));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: "internal error" },
                })
                    .catch((error) => this.emit("error", error));
            }
            const externalHandler = this._externals.get(method);
            if (externalHandler === undefined) {
                this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.ExternalNotFoundError(method)));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: {
                        jobId,
                        requestId,
                        method,
                        message: `external function ${method} not found`,
                    },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            let result;
            try {
                result = await externalHandler(parameters, conv);
            }
            catch (error) {
                const errorMessage = (error === null || error === void 0 ? void 0 : error.message) ? String(error.message) : String(error);
                this.log.warn(`external function error: ${errorMessage}`, error);
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: { jobId, requestId, method, message: errorMessage },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            this._processingClient
                .sendRpcResponse({
                instanceId: this._instanceId,
                rpcResponse: { jobId, requestId, method, result },
            })
                .catch((error) => this.emit("error", error));
        };
        //#region http requests
        this._handleHttpRequest = async (request) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            var _l, _m;
            const { jobId, requestId, method: rpcMethod, parameters } = request;
            if (rpcMethod === "internalCall/logWarning") {
                if ((parameters === null || parameters === void 0 ? void 0 : parameters.message) !== undefined &&
                    (parameters === null || parameters === void 0 ? void 0 : parameters.message) !== null &&
                    typeof parameters.message === "string") {
                    this.log.warn(`[${jobId}]: '${parameters.message}'`);
                }
                return;
            }
            if (rpcMethod === "internalCall/dynamicTool") {
                await this._handleDynamicTool(jobId, requestId, rpcMethod, parameters);
                return;
            }
            if (rpcMethod !== "internalCall/httpRequest")
                return;
            if (this._state === ApplicationState.Initial || this._state === ApplicationState.Stopped) {
                this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.Error("application is not running")));
                this._processingClient
                    .sendRpcError({
                    instanceId: this._instanceId,
                    rpcError: {
                        jobId,
                        requestId,
                        method: rpcMethod,
                        message: "application instance was not running",
                    },
                })
                    .catch((error) => this.emit("error", error));
                return;
            }
            try {
                if (this.axios === null) {
                    throw new Error("http requests are forbidden for this application");
                }
                (0, assert_1.default)(typeof parameters.url === "string");
                (0, assert_1.default)(typeof parameters.method === "string");
                (0, assert_1.default)(typeof parameters.headers === "object" && parameters.headers !== null);
                (0, assert_1.default)(parameters.requestType === "json" || parameters.requestType === "text");
                (0, assert_1.default)(parameters.responseType === "json" || parameters.responseType === "text");
                (0, assert_1.default)(typeof parameters.timeout === "number");
                let rawRequestBody;
                if (parameters.body !== null && parameters.body !== undefined) {
                    rawRequestBody = String(parameters.body);
                    if (parameters.requestType === "json") {
                        (_a = (_l = parameters.headers)["Content-Type"]) !== null && _a !== void 0 ? _a : (_l["Content-Type"] = "application/json");
                        rawRequestBody = JSON.stringify(parameters.body);
                    }
                    if (parameters.requestType === "text") {
                        (_b = (_m = parameters.headers)["Content-Type"]) !== null && _b !== void 0 ? _b : (_m["Content-Type"] = "text/plain");
                    }
                }
                const response = await this.axios.request({
                    method: parameters.method,
                    url: parameters.url,
                    headers: { ...this.axios.defaults.headers.common, ...parameters.headers },
                    data: rawRequestBody,
                    timeout: parameters.timeout,
                    responseType: "text",
                    validateStatus: this.axios.defaults.validateStatus === axios_1.default.defaults.validateStatus
                        ? () => true
                        : undefined,
                });
                let responseBody = response.data;
                if (parameters.responseType === "json") {
                    try {
                        responseBody = (_c = JSON.parse(response.data)) !== null && _c !== void 0 ? _c : null;
                    }
                    catch (error) {
                        // sic
                    }
                }
                const result = {
                    status: response.status,
                    statusText: response.statusText,
                    headers: response.headers,
                    responseType: parameters.responseType,
                    body: responseBody,
                    rawBody: response.data,
                };
                this._processingClient
                    .sendRpcResponse({
                    instanceId: this._instanceId,
                    rpcResponse: { jobId, requestId, method: rpcMethod, result },
                })
                    .catch((error) => this.emit("error", error));
            }
            catch (error) {
                const errorMessage = (error === null || error === void 0 ? void 0 : error.message) ? String(error.message) : String(error);
                this.log.warn(`http request error: ${errorMessage}`, error);
                if ((0, axios_1.isAxiosError)(error)) {
                    this._processingClient
                        .sendRpcResponse({
                        instanceId: this._instanceId,
                        rpcResponse: {
                            jobId, requestId, method: rpcMethod, result: {
                                status: (_d = error.status) !== null && _d !== void 0 ? _d : 500,
                                statusText: (_f = (_e = error.response) === null || _e === void 0 ? void 0 : _e.statusText) !== null && _f !== void 0 ? _f : errorMessage,
                                headers: (_h = (_g = error.response) === null || _g === void 0 ? void 0 : _g.headers) !== null && _h !== void 0 ? _h : {},
                                responseType: parameters.responseType,
                                body: null,
                                rawBody: (_k = (_j = error.response) === null || _j === void 0 ? void 0 : _j.data) !== null && _k !== void 0 ? _k : "",
                            }
                        }
                    }).catch((error) => this.emit("error", error));
                }
                else {
                    this._processingClient
                        .sendRpcError({
                        instanceId: this._instanceId,
                        rpcError: { jobId, requestId, method: rpcMethod, message: errorMessage },
                    })
                        .catch((error) => this.emit("error", error));
                }
                return;
            }
        };
        this._handleJobTimedOut = (jobId, jobKey) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobTimedOut", jobId, jobKey);
        };
        this._handleJobRejected = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobRejected", jobId, jobKey, jobData);
        };
        this._handleJobStarting = (jobId, jobKey, jobData) => {
            this.emit("_jobStarting", jobId, jobKey, jobData);
        };
        this._activeConversationsByJobId = new Map();
        this._handleJobFailed = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobFailed", jobId, jobKey, jobData);
        };
        this._handleJobCompleted = (jobId, jobKey, jobData) => {
            this._activeConversationsByJobId.delete(jobId);
            this.emit("_jobCompleted", jobId, jobKey, jobData);
        };
        this._handleJobRecordIdReady = (jobId, jobKey, recordId, recordIds) => {
            this.emit("_jobRecordIdReady", jobId, recordId, recordIds);
        };
        this._handleJobAdditionalInformation = (jobId, jobKey, data) => {
            this.emit("_jobAdditionalInformation", jobId, data);
        };
        this._handleJobEvent = (jobId, jobEvent) => {
            this.emit("_jobEvent", jobId, jobEvent);
        };
        //#endregion
        //#region logging
        this._handleDebugLog = (jobId, message) => {
            this.log.info(message, { jobId, label: "application" });
            this.emit("_jobDebugLog", jobId, message);
        };
        //#endregion
        //#region stt provider
        /**
         * An {@link SttDispatcher} callback that selects a speech-to-text engine
         * for all new conversations. If not set explicitly, a `"default"`
         * {@link SttProviderName | STT provider} will be used.
         *
         * @deprecated use {@link Conversation.audio.stt} instead
         */
        this.sttDispatcher = () => "default";
        //#endregion
        //#region tts provider
        /**
         * A {@link TtsDispatcher} callback that selects a text-to-speech engine
         * for all new conversations. If not set explicitly, a `"default"`
         * {@link TtsProviderName | TTS provider} will be used.
         *
         * @deprecated use {@link Conversation.audio.tts} instead
         */
        this.ttsDispatcher = () => "default";
        /**
         * A {@link CustomTtsProvider} callback to use when the {@link TtsProviderName | TTS provider}
         * is set to `"custom"` in {@link Conversation.audio.tts}.
         */
        this.customTtsProvider = () => {
            // imitates an error thrown by a user-supplied connection provider
            // thus, no custom errors or explicit logging here; it all happens at call site
            throw new Error("customTtsProvider was not set");
        };
        this._handleTtsRequest = async (request) => {
            const { requestId, messageId, text, voiceInfo } = request;
            try {
                if (this.customTtsProvider === undefined) {
                    throw new Error("no TTS provider is set");
                }
                let result = await this.customTtsProvider(text, voiceInfo);
                // have to use duck typing since Fetch API may not be present
                if (!(result instanceof audio.Audio)) {
                    result = await audio.fromFetchResponse(result);
                }
                await this._externalTtsClient.sendAudioData({
                    instanceId: this._instanceId,
                    requestId,
                    messageId,
                    audio: {
                        format: result._format,
                        data: result._data,
                    },
                });
            }
            catch (error) {
                try {
                    await this._externalTtsClient.sendAudioError({
                        instanceId: this._instanceId,
                        requestId,
                        messageId,
                        error: { type: error.name, message: error.message, details: "" },
                    });
                }
                catch (error) {
                    this.emit("error", error);
                }
                if (error instanceof errors.Error) {
                    this.emit("error", error);
                }
                else {
                    this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.CustomTtsProviderError(error)));
                }
            }
        };
        //#endregion
        //#region disposable
        this._isDisposed = false;
        this.log = options.log.child({
            label: `app:${instanceId.slice(-6)}`,
            applicationId,
            instanceId,
            applicationName,
        });
        processingClient.enrichLoggerMeta(this.log.defaultMeta);
        externalTtsClient.enrichLoggerMeta(this.log.defaultMeta);
        instanceStream.enrichLoggerMeta(this.log.defaultMeta);
        this.log.info(`applicationId: ${applicationId}`);
        this.log.info(`applicationName: ${applicationName}`);
        this.log.info(`instanceId: ${instanceId}`);
        this._applicationZip = options.applicationZip;
        this.account = options.account;
        this._healthcheckInterval = options.healthcheckInterval;
        this._reconnectInterval = options.reconnectInterval;
        this._maxReconnectCount = options.maxReconnectCount;
        this.axios = options.axios;
        this.applicationId = applicationId;
        this.applicationName = applicationName;
        this._instanceId = instanceId;
        this.customerId = options.customerId;
        this.groupId = options.groupId;
        this._externalTtsClient = externalTtsClient;
        this._processingClient = processingClient;
        this._instanceStream = instanceStream;
        this.inputSchema = inputSchema;
        this.outputSchema = outputSchema;
        this._runtimeStream = processingClient.runtimeStream({ instanceId });
        this._debugStream = processingClient.debugStream({ instanceId });
        this._audioServerStream = processingClient.audioServerStream({ instanceId });
        this._audioRequestStream = this._externalTtsClient.audioRequestStream({ instanceId });
        this._instanceStream.on("error", this._handleStreamError);
        this._runtimeStream.on("error", this._handleStreamError);
        this._debugStream.on("error", this._handleStreamError);
        this._audioServerStream.on("error", this._handleStreamError);
        this._audioRequestStream.on("error", this._handleStreamError);
        this._instanceStream.on("jobTimedOut", this._handleJobTimedOut);
        this._instanceStream.on("jobRejected", this._handleJobRejected);
        this._instanceStream.on("jobStarting", this._handleJobStarting);
        this._instanceStream.on("jobFailed", this._handleJobFailed);
        this._instanceStream.on("jobCompleted", this._handleJobCompleted);
        this._instanceStream.on("jobRecordIdReady", this._handleJobRecordIdReady);
        this._instanceStream.on("jobAdditionalInformation", this._handleJobAdditionalInformation);
        this._runtimeStream.on("rpcRequest", this._handleRpcRequest);
        this._runtimeStream.on("internalRpcRequest", this._handleHttpRequest);
        this._debugStream.on("jobEvent", this._handleJobEvent);
        this._debugStream.on("debugLog", this._handleDebugLog);
        this._audioRequestStream.on("request", this._handleTtsRequest);
        this.queue = new queue_1.ConversationQueue(this, this.log);
        this.queue.on("error", (error) => this.emit("error", error));
        this._healthcheckIntervalHandle = setInterval(this._healthcheck, this._healthcheckInterval);
    }
    /**
     * Start the deployed application, enabling it to receive incoming requests
     * and run queued conversations.
     *
     * @param options.concurrency max number of conversations to run at once
     */
    async start(options) {
        var _a;
        if (this._state === ApplicationState.Running) {
            (0, log_1.logAndThrow)(this.log, new errors.Error("application is already running"));
        }
        if (this._state === ApplicationState.Stopping) {
            (0, log_1.logAndThrow)(this.log, new errors.Error("application is stopping"));
        }
        this._state = ApplicationState.Running;
        this._concurrency = (_a = options === null || options === void 0 ? void 0 : options.concurrency) !== null && _a !== void 0 ? _a : 1;
        await this._processingClient.setInstanceConcurrency({
            instanceId: this._instanceId,
            concurrency: this._concurrency,
        });
        this.log.info(`application started with concurrency ${this._concurrency}`);
    }
    /**
     * Stop the running application, disabling the creation of new conversations.
     * Conversations that are already running are unaffected.
     */
    async stop(options) {
        if (this._state !== ApplicationState.Running) {
            (0, log_1.logAndReturn)(this.log, new errors.Error("application is not running"));
            return;
        }
        this._state = ApplicationState.Stopping;
        this._concurrency = 0;
        await this._processingClient.setInstanceConcurrency({
            instanceId: this._instanceId,
            concurrency: this._concurrency,
        });
        this.log.info("application instance concurrency set to 0");
        if (options === null || options === void 0 ? void 0 : options.waitUntilAllProcessed) {
            await this.waitUntilCurrentProcessed({
                checkPeriodInMs: options === null || options === void 0 ? void 0 : options.checkPeriodInMs,
                cancelationToken: options === null || options === void 0 ? void 0 : options.cancelationToken
            });
            await this.queue.waitUntilCurrentProcessed({
                checkPeriodInMs: options === null || options === void 0 ? void 0 : options.checkPeriodInMs,
                cancelationToken: options === null || options === void 0 ? void 0 : options.cancelationToken
            });
        }
        this._state = ApplicationState.Stopped;
        this.log.info("application stopped");
    }
    async healthCheck() {
        const api = new rest.DiagnosticsApi(this.account, this.log);
        try {
            this.log.debug(`Requesting a server-side healthcheck`);
            await api.getInstanceLimits({ instanceId: this._instanceId });
            this.log.debug(`Server-side healthcheck ok`);
        }
        catch (error) {
            this.log.warn(`Application unhealthy. Found connection issues.`, {
                error: error
            });
            this.log.debug(error);
            return false;
        }
        const instanceHealth = this._instanceStream.healthCheck();
        const audioServerHealth = this._audioServerStream.healthCheck();
        const ttsHealth = this._audioRequestStream.healthCheck();
        const debugHealth = this._debugStream.healthCheck();
        const runtimeHealth = this._runtimeStream.healthCheck();
        const proccessingClientHealth = this._processingClient.healthCheck();
        const audioClientHealth = this._externalTtsClient.healthCheck();
        const healthy = instanceHealth && audioServerHealth &&
            ttsHealth && debugHealth && runtimeHealth
            && proccessingClientHealth &&
            audioServerHealth && audioClientHealth;
        if (healthy) {
            this.log.debug(`Application healthy.`);
            return true;
        }
        const healthyObject = {
            instanceHealth,
            audioServerHealth,
            ttsHealth,
            debugHealth,
            runtimeHealth,
            proccessingClientHealth,
            audioClientHealth
        };
        this.log.warn(`Application unhealty. '${JSON.stringify(healthyObject)}'`, healthyObject);
        return false;
    }
    async _reconnect(error) {
        try {
            if (this.reconnectInProgress) {
                return;
            }
            this.reconnectInProgress = true;
            await this._reconnectInternal(error);
        }
        finally {
            this.reconnectInProgress = false;
        }
    }
    async _reconnectInternal(error) {
        for (let reconnectCount = 0; reconnectCount < this._maxReconnectCount; reconnectCount += 1) {
            if (!error || (error instanceof errors.ConnectionError && error.reconnectable)) {
                try {
                    this.emit("reconnecting", reconnectCount);
                    await this._attemptReconnection(reconnectCount);
                    return;
                }
                catch (reconnectError) {
                    error = reconnectError;
                }
            }
            else {
                this.emit("error", error);
                this.emit("unableToReconnect", error);
                return;
            }
        }
        this.emit("unableToReconnect", new Error("reconnection limit reached"));
        this.log.info("reconnection limit reached");
    }
    async _attemptReconnection(reconnectCount) {
        // TODO: is this okay?
        for (const conv of this._activeConversationsByJobId.values()) {
            this.emit("_jobFailed", conv._jobId, conv._jobKey, { msg: "connection error" });
        }
        this._activeConversationsByJobId.clear();
        this._audioServerStream.cancel();
        for (const stream of this._audioClientStreams)
            stream.cancel();
        this._audioClientStreams = [];
        this._debugStream.cancel();
        this._runtimeStream.cancel();
        this._instanceStream.cancel();
        this._audioRequestStream.cancel();
        if (this._healthcheckIntervalHandle) {
            clearInterval(this._healthcheckIntervalHandle);
            this._healthcheckIntervalHandle = undefined;
        }
        const interval = typeof this._reconnectInterval === "number"
            ? this._reconnectInterval
            : this._reconnectInterval(reconnectCount);
        this.log.info(`reconnecting in ${interval} ms`);
        await new Promise((cb) => setTimeout(cb, interval));
        this.log.info("reconnecting");
        this._instanceStream = this._processingClient.registerInstanceStream({
            applicationZip: this._applicationZip,
            concurrency: this._concurrency,
            instanceId: this._instanceId,
            groupId: this.groupId,
            sdkVersion: sdkVersion,
        });
        await new Promise((resolve, reject) => {
            this._instanceStream.on("error", (error) => {
                this._instanceStream.removeAllListeners();
                reject(error);
            });
            this._instanceStream.on("success", (applicationId, instanceId) => {
                this._instanceStream.removeAllListeners();
                this.applicationId = applicationId;
                this._instanceId = instanceId;
                resolve();
            });
        });
        this._runtimeStream = this._processingClient.runtimeStream({ instanceId: this._instanceId });
        this._debugStream = this._processingClient.debugStream({ instanceId: this._instanceId });
        this._audioServerStream = this._processingClient.audioServerStream({
            instanceId: this._instanceId,
        });
        this._audioRequestStream = this._externalTtsClient.audioRequestStream({
            instanceId: this._instanceId,
        });
        this._instanceStream.on("error", this._handleStreamError);
        this._runtimeStream.on("error", this._handleStreamError);
        this._debugStream.on("error", this._handleStreamError);
        this._audioRequestStream.on("error", this._handleStreamError);
        this._instanceStream.on("jobTimedOut", this._handleJobTimedOut);
        this._instanceStream.on("jobRejected", this._handleJobRejected);
        this._instanceStream.on("jobStarting", this._handleJobStarting);
        this._instanceStream.on("jobFailed", this._handleJobFailed);
        this._instanceStream.on("jobCompleted", this._handleJobCompleted);
        this._instanceStream.on("jobRecordIdReady", this._handleJobRecordIdReady);
        this._instanceStream.on("jobAdditionalInformation", this._handleJobAdditionalInformation);
        this._runtimeStream.on("rpcRequest", this._handleRpcRequest);
        this._runtimeStream.on("internalRpcRequest", this._handleHttpRequest);
        this._debugStream.on("jobEvent", this._handleJobEvent);
        this._debugStream.on("debugLog", this._handleDebugLog);
        this._audioRequestStream.on("request", this._handleTtsRequest);
        if (this._healthcheckIntervalHandle) {
            clearInterval(this._healthcheckIntervalHandle);
            this._healthcheckIntervalHandle = undefined;
        }
        this._healthcheckIntervalHandle = setInterval(this._healthcheck, this._healthcheckInterval);
        this.log.info(`reconnected with instanceId ${this._instanceId}`);
    }
    /** @internal */
    async _executeConnectionProvider(conv) {
        try {
            if (this.connectionProvider === undefined)
                throw new Error("connectionProvider was not set");
            const connection = await this.connectionProvider(conv);
            if (connection === undefined)
                throw new Error("connection provider returned no connection");
            return connection;
        }
        catch (error) {
            (0, log_1.logAndThrow)(this.log, new errors.ConnectionProviderError(error));
        }
    }
    /** @internal */
    async _addSessionConfig(config) {
        let configJson;
        try {
            configJson = JSON.stringify(config);
        }
        catch (error) {
            this.log.debug(error);
            (0, log_1.logAndThrow)(this.log, new errors.InternalError("session config is not serializable to JSON", error));
        }
        if (configJson === undefined) {
            (0, log_1.logAndThrow)(this.log, new errors.InternalError("session config is not serializable to JSON"));
        }
        const configZip = await zip.file("config.json", configJson, this.log);
        return await this._processingClient.addSessionConfig({
            instanceId: this._instanceId,
            configZip,
        });
    }
    /** @internal */
    async _sendEvent(jobId, eventName, eventValue) {
        return this._processingClient
            .sendRpcRequest({
            instanceId: this._instanceId,
            rpcRequest: { jobId: jobId, method: "sdkInternalCall/triggerEvent", requestId: 0, parameters: {
                    eventName: eventName,
                    eventValue: eventValue
                } },
        })
            .catch((error) => this.emit("error", error));
    }
    /** @internal */
    async _configureSession(conversation, executionOptions) {
        var _a, _b;
        const config = {};
        if (executionOptions.channel === "audio") {
            config.type = "audio";
            config.channel = {
                type: "sip",
                configName: (_b = (_a = conversation.sip) === null || _a === void 0 ? void 0 : _a.config) !== null && _b !== void 0 ? _b : "default",
            };
            config.stt = stt._makeSttSessionConfig(conversation.audio.stt, this.log);
            config.tts = tts._makeTtsSessionConfig(conversation.audio.tts, this.log);
            config.vad = {
                delayAtStartup: conversation.audio.vadStartupDelay,
                interlocutorPauseDelay: conversation.audio.vadPauseDelay,
            };
            config.noiseVolume = conversation.audio.noiseVolume;
            config.interruptDelay = conversation.audio.interruptDelay;
        }
        else if (executionOptions.channel === "text") {
            config.type = "text";
        }
        config.experimental = {
            "dynamic_tools": JSON.stringify(Object.values(conversation._dynamicTools).map(x => ({
                description: x.description,
                name: x.name,
                parameters: x.schema
            })))
        };
        config.saveLog = true;
        return await this._processingClient.addSessionConfig({
            instanceId: this._instanceId,
            configZip: await zip.file("config.json", JSON.stringify(config), this.log),
        });
    }
    /**
     * Set an [external call] handler for this application.
     *
     * The handler is called with all the call arguments passed as a dictionary,
     * as well as the current {@link Conversation} object. It can return a JSON-serializable
     * value, possibly wrapped in a promise, which then is treated as the call's return value.
     * As a special case, `undefined` gets converted to `null`.
     *
     * [external call]: https://docs.dasha.ai/en-us/default/dasha-script-language/external-functions
     */
    setExternal(name, fn) {
        this._externals.set(name, fn);
    }
    //#endregion
    async _handleDynamicTool(jobId, requestId, rpcMethod, parameters) {
        const conv = this._activeConversationsByJobId.get(jobId);
        if (conv === undefined) {
            this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.InternalError()));
            this._processingClient
                .sendRpcError({
                instanceId: this._instanceId,
                rpcError: { jobId, requestId, method: rpcMethod, message: "conversation not found" },
            })
                .catch((error) => this.emit("error", error));
            return;
        }
        const name = parameters.name;
        if (name === undefined) {
            this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.ExternalNotFoundError(rpcMethod)));
            this._processingClient
                .sendRpcError({
                instanceId: this._instanceId,
                rpcError: {
                    jobId,
                    requestId,
                    method: rpcMethod,
                    message: `Internal error`,
                },
            })
                .catch((error) => this.emit("error", error));
            return;
        }
        const handler = conv === null || conv === void 0 ? void 0 : conv._dynamicTools[name];
        if (handler === undefined) {
            this.emit("error", (0, log_1.logAndReturn)(this.log, new errors.ExternalNotFoundError(name)));
            this._processingClient
                .sendRpcError({
                instanceId: this._instanceId,
                rpcError: {
                    jobId,
                    requestId,
                    method: rpcMethod,
                    message: `Tool ${name} not found`,
                },
            })
                .catch((error) => this.emit("error", error));
            return;
        }
        let result;
        try {
            result = await handler.handle(parameters.args, conv);
        }
        catch (error) {
            const errorMessage = (error === null || error === void 0 ? void 0 : error.message) ? String(error.message) : String(error);
            this.log.warn(`dynamic tool ${name} error: ${errorMessage}`, error);
            this._processingClient
                .sendRpcError({
                instanceId: this._instanceId,
                rpcError: { jobId, requestId, method: rpcMethod, message: errorMessage },
            })
                .catch((error) => this.emit("error", error));
            return;
        }
        this._processingClient
            .sendRpcResponse({
            instanceId: this._instanceId,
            rpcResponse: { jobId, requestId, method: rpcMethod, result },
        })
            .catch((error) => this.emit("error", error));
        return;
    }
    //#endregion
    //#region job lifecycle
    /** @internal */
    async _enqueueJob(jobKey, options) {
        var _a;
        const result = await this._processingClient.enqueueJob({
            instanceId: this._instanceId,
            jobs: [
                {
                    jobId: jobKey,
                    priority: options.priority,
                    after: options.after,
                    before: options.before,
                    input: (_a = options.input) !== null && _a !== void 0 ? _a : {}
                },
            ],
        });
        return { jobId: result[0].assignedJobId };
    }
    /** @internal */
    async _acceptJob(jobId, options) {
        await this._processingClient.acceptJob({ instanceId: this._instanceId, jobId, ...options });
    }
    /** @internal */
    async _rejectJob(jobId) {
        await this._processingClient.rejectJob({ instanceId: this._instanceId, jobId });
    }
    /** @internal */
    _bindConversation(jobId, conv) {
        this._activeConversationsByJobId.set(jobId, conv);
    }
    //#endregion
    //#region conversations
    /**
     * Create a single {@link Conversation}.
     *
     * @param input conversation's input data;
     *   can also be set later with {@link Conversation.input}
     */
    createConversation(input) {
        /** @todo emit id and input data to capture it in observer */
        if (this._state !== ApplicationState.Running) {
            (0, log_1.logAndThrow)(this.log, new errors.Error("application is not running"));
        }
        const conv = new conversation_1.SingleConversation(this, input, this.log);
        this.emit("_singleConversationCreated", conv);
        return conv;
    }
    /** @internal */
    async _executeSttDispatcher(conv) {
        try {
            const providerName = await this.sttDispatcher(conv);
            if (providerName === undefined)
                throw new Error("stt dispather returned no provider name");
            return stt._makeSttSessionConfig(providerName, this.log);
        }
        catch (error) {
            (0, log_1.logAndThrow)(this.log, new errors.SttDispatcherError(error));
        }
    }
    /** @internal */
    async _executeTtsDispatcher(conv) {
        try {
            const providerName = await this.ttsDispatcher(conv);
            if (providerName === undefined)
                throw new Error("tts dispatcher returned no provider name");
            return tts._makeTtsSessionConfig(providerName, this.log);
        }
        catch (error) {
            (0, log_1.logAndThrow)(this.log, new errors.TtsDispatcherError(error));
        }
    }
    //#endregion
    //#region call recordings
    /** @internal */
    _getRecordingUrl(callId) {
        return `${(0, account_1.getBaseHttpUrl)(this.account)}/api/v1/records/${callId}`;
    }
    /**
     * Close the connection with the application, freeing all local resources.
     */
    dispose() {
        if (this._isDisposed)
            return;
        this._isDisposed = true;
        this.queue._dispose();
        this._audioRequestStream.cancel();
        this._externalTtsClient.close();
        this._audioServerStream.cancel();
        for (const stream of this._audioClientStreams)
            stream.cancel();
        this._debugStream.cancel();
        this._runtimeStream.cancel();
        this._instanceStream.cancel();
        this._processingClient.close();
        if (this._healthcheckIntervalHandle) {
            clearInterval(this._healthcheckIntervalHandle);
            this._healthcheckIntervalHandle = undefined;
        }
        this.emit("_disposed");
        this.removeAllListeners();
        this.log.info("application disposed of");
    }
    async waitUntilCurrentProcessed(options) {
        var _a, _b;
        const sleep = (ms) => new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
        const sleepInMs = (_a = options === null || options === void 0 ? void 0 : options.checkPeriodInMs) !== null && _a !== void 0 ? _a : 1000;
        while (this._activeConversationsByJobId.size > 0) {
            this.log.info(`There are ${this._activeConversationsByJobId.size} jobs waiting to be completed. SingleConversation`);
            if ((_b = options === null || options === void 0 ? void 0 : options.cancelationToken) === null || _b === void 0 ? void 0 : _b.isCanceled) {
                return false;
            }
            await sleep(sleepInMs);
        }
        this.log.info(`All processing jobs completed. ${this._activeConversationsByJobId.size} jobs. SingleConversation`);
        return true;
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map