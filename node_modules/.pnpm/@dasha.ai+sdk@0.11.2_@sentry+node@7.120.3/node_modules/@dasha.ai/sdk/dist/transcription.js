"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscriptionParser = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const isObject = (x) => typeof x === "object" && x !== null;
class TranscriptionParser extends eventemitter3_1.default {
    constructor() {
        super(...arguments);
        this._incomingVoiceSegments = new Map();
        this._routeNames = new Map();
    }
    push(jobEvent) {
        var _a;
        if (!isObject(jobEvent))
            return;
        if (typeof jobEvent.time !== "string")
            return;
        const { msg } = jobEvent;
        if (!isObject(msg))
            return;
        const routeId = (_a = msg.routeId) !== null && _a !== void 0 ? _a : "";
        if ("voiceSegmentId" in msg) {
            const state = this._incomingVoiceSegments.get(msg.voiceSegmentId);
            switch (state === null || state === void 0 ? void 0 : state.state) {
                case undefined:
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Voice") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "voice",
                            startTime: new Date(jobEvent.time),
                            name: this._routeNames.get(routeId)
                        });
                    }
                    break;
                case "voice":
                    if (msg.textMsgId === "FinalTextChannelMessage") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "final",
                            startTime: state.startTime,
                            text: String(msg.text),
                            name: state.name
                        });
                    }
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Pause") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "pause",
                            startTime: state.startTime,
                            endTime: new Date(jobEvent.time),
                            name: state.name
                        });
                    }
                    break;
                case "final":
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Pause") {
                        this._incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "pause",
                            startTime: state.startTime,
                            endTime: new Date(jobEvent.time),
                            name: state.name
                        });
                        if (state.text && state.text.trim().length !== 0) {
                            this._incomingVoiceSegments.delete(msg.voiceSegmentId);
                            this.emit("transcription", {
                                speaker: "human",
                                text: state.text,
                                startTime: state.startTime,
                                endTime: new Date(jobEvent.time),
                                name: state.name
                            });
                        }
                    }
                    break;
                case "pause":
                    if (msg.textMsgId === "ConfidentTextChannelMessage") {
                        this._incomingVoiceSegments.delete(msg.voiceSegmentId);
                        this.emit("transcription", {
                            speaker: "human",
                            text: String(msg.text),
                            startTime: state.startTime,
                            endTime: state.endTime,
                            name: state.name,
                        });
                    }
                    break;
            }
        }
        if (msg.msgId === "StoppedPlayingAudioChannelMessage" && msg.PlayedText !== null && msg.PlayedText !== "") {
            this.emit("transcription", {
                speaker: "ai",
                text: String(msg.PlayedText),
                startTime: new Date(String(msg.StartPlayingTime)),
                endTime: new Date(String(msg.EndPlayingTime))
            });
        }
        if (msg.msgId === "OpenSessionChannelMessage" && msg.options !== undefined) {
            const speakerName = msg.options.humanName;
            this._routeNames.set(routeId, speakerName);
        }
    }
    dispose() {
        this.removeAllListeners();
    }
}
exports.TranscriptionParser = TranscriptionParser;
//# sourceMappingURL=transcription.js.map