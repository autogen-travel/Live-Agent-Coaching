"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAppZipData = prepareAppZipData;
const path_1 = __importDefault(require("path"));
const json_1 = require("./json");
const fs_1 = __importDefault(require("fs"));
const dasha_packages_1 = require("./json/generated/dasha-packages");
const errors_1 = require("./file-system/errors");
function strMatchesPattern(str, mask) {
    if (mask.startsWith("*")) {
        return str.endsWith(mask.slice(1));
    }
    return str === mask;
}
async function findFilesInDir(dirpath, isRecursive, fileMask) {
    const files = await fs_1.default.promises.readdir(dirpath);
    const result = [];
    for (const file of files) {
        const absPath = path_1.default.resolve(dirpath, file);
        const stat = await fs_1.default.promises.stat(absPath);
        if (isRecursive && stat.isDirectory()) {
            result.push(...(await findFilesInDir(absPath, isRecursive, fileMask)));
        }
        if (stat.isFile()) {
            if (fileMask === undefined) {
                result.push(absPath);
            }
            else if (strMatchesPattern(file, fileMask)) {
                result.push(absPath);
            }
        }
    }
    return result;
}
function removeDslComments(dslFileContent) {
    return dslFileContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "").trim();
}
function parseDslImports(dslFileContent) {
    /** matches both:
     * regular import, e.g. `import "../path/to/file.dsl";` -> [`../path/to/file.dsl`]
     * package import, e.g. `import "./example" from "some.package";` -> [`./example`, `some.package`]
     * */
    const importRE = /import\s*(?:"([^"\r\n]*)")(?:\s*from\s*(?:"([^"\r\n]*)"))?/g;
    const content = removeDslComments(dslFileContent);
    let match;
    const importPaths = [];
    while ((match = importRE.exec(content)) !== null) {
        const dslPath = match[1];
        const packageName = match[2];
        /** check if it is package import */
        if (packageName !== undefined)
            continue;
        importPaths.push(dslPath);
    }
    return importPaths;
}
async function tryFindSingleFile(directory, isRecursive, fileMask) {
    const files = await findFilesInDir(directory, isRecursive, fileMask);
    if (files.length === 0)
        throw new Error(`No '${fileMask}' file was found in path '${directory}'`);
    if (files.length > 1) {
        throw new Error(`Multiple '${fileMask}' files were detected: ${files.join(", ")}`);
    }
    const dashaappFilePath = files[0];
    return dashaappFilePath;
}
async function parseValidateAppConfig(appConfigPath) {
    var _a;
    let config;
    try {
        config = JSON.parse(await fs_1.default.promises.readFile(appConfigPath, "utf8"));
    }
    catch (e) {
        throw new Error(`Could not parse .dashaapp config file: ${e.message}`);
    }
    if (!json_1.ApplicationConfig.validate(config)) {
        throw new Error((_a = json_1.ApplicationConfig.validate.errors) === null || _a === void 0 ? void 0 : _a.join("\n"));
    }
    return config;
}
async function parseValidatePackagesConfig(packagesConfigPath) {
    var _a;
    let config;
    try {
        config = JSON.parse(await fs_1.default.promises.readFile(packagesConfigPath, "utf8"));
    }
    catch (e) {
        throw new Error(`Could not parse dasha packages config file: ${e.message}`);
    }
    if (!dasha_packages_1.DashaPackages.validate(config)) {
        throw new Error((_a = dasha_packages_1.DashaPackages.validate.errors) === null || _a === void 0 ? void 0 : _a.join("\n"));
    }
    return config;
}
async function resolvePackagesPaths(appFolderPath, packagesConfig) {
    var _a;
    const packagesFolderName = (_a = packagesConfig.packagesFolderPath) !== null && _a !== void 0 ? _a : "dasha-packages";
    const packagesPath = path_1.default.join(appFolderPath, packagesFolderName);
    /** check folder exists */
    try {
        await fs_1.default.promises.access(packagesPath);
    }
    catch (e) {
        throw new errors_1.PathNotExistsError(packagesPath, e);
    }
    const availablePackages = {};
    for (const packageName of await fs_1.default.promises.readdir(packagesPath)) {
        const absPath = path_1.default.resolve(path_1.default.join(packagesPath, packageName));
        const isDir = await fs_1.default
            .promises
            .lstat(absPath)
            .then((stat) => {
            return stat.isDirectory();
        })
            .catch((e) => {
            return false;
        });
        if (isDir)
            availablePackages[packageName] = absPath;
    }
    const packageToAbsPath = {};
    for (const requiredPackage of Object.keys(packagesConfig.locks)) {
        if (!Object.keys(availablePackages).includes(requiredPackage)) {
            throw new Error(`Package '${requiredPackage}' was not found in packages folder.`);
        }
        packageToAbsPath[requiredPackage] = availablePackages[requiredPackage];
    }
    return packageToAbsPath;
}
async function collectDslFilePathsInner(dslFilePath, result) {
    await fs_1.default
        .promises
        .lstat(dslFilePath)
        .catch((e) => {
        throw new Error(`File ${dslFilePath} was not found`);
    })
        .then((f) => {
        if (!f.isFile() || path_1.default.parse(dslFilePath).ext !== ".dsl")
            throw new Error(`${dslFilePath} is not a dsl file`);
    });
    if (result.includes(dslFilePath))
        return;
    result.push(dslFilePath);
    const dslFileContent = await fs_1.default.promises.readFile(dslFilePath, "utf8");
    const importedRelPaths = parseDslImports(dslFileContent);
    for (const relPath of importedRelPaths) {
        const absPath = path_1.default.resolve(path_1.default.parse(dslFilePath).dir, relPath);
        await collectDslFilePathsInner(absPath, result);
    }
}
async function collectDslFilePaths(mainFilePath) {
    const result = [];
    await collectDslFilePathsInner(mainFilePath, result);
    return result;
}
async function getRootFolder(filePaths) {
    if (filePaths.length === 1)
        return path_1.default.dirname(filePaths[0]);
    const rootFolderSplit = filePaths.reduce((prev, cur, curInd) => {
        cur = path_1.default.normalize(cur).split(path_1.default.sep);
        if (curInd === 1)
            prev = path_1.default.normalize(prev).split(path_1.default.sep);
        const largest = prev.length > cur.length ? prev : cur;
        for (const ind in largest) {
            if (cur[ind] != prev[ind])
                return prev.slice(0, ind);
        }
        return cur;
    });
    let rootFolder = rootFolderSplit.join(path_1.default.sep);
    if (!rootFolder.includes(path_1.default.sep))
        rootFolder += path_1.default.sep;
    return rootFolder;
}
/**
 * Collects files used in application and prepares them for archiving.
 * Archived dsl files are stored in the folder '__dsl_dialogue',
 *  for this reason, the dialogue root file path is fixed in application config content.
 * The other archived file paths are relative paths for 'appFolderPath'
 * @param appFolderPath Application folder with single .dashaapp file in the root
 * @returns mapping of archive path to content.
 */
async function prepareAppZipData(appFolderPath) {
    var _a, _b;
    let packagesConfig = undefined;
    let packagesConfigFilePathAbs = undefined;
    const files = await findFilesInDir(appFolderPath, false, "dasha-packages.json");
    if (files.length > 1) {
        throw new Error(`Multiple 'dasha-packages.json' files were detected: ${files.join(", ")}`);
    }
    packagesConfigFilePathAbs = files[0];
    if (packagesConfigFilePathAbs) {
        packagesConfig = await parseValidatePackagesConfig(packagesConfigFilePathAbs);
    }
    const dashaappFilePathAbs = path_1.default.resolve(await tryFindSingleFile(appFolderPath, false, "*.dashaapp"));
    /** collect absolute paths of application files */
    const appConfig = await parseValidateAppConfig(dashaappFilePathAbs);
    const resolveConfigPath = (p) => {
        const relPath = path_1.default.join(path_1.default.parse(dashaappFilePathAbs).dir, p);
        return path_1.default.resolve(relPath);
    };
    const appFilePathsAbs = {
        mainDsl: resolveConfigPath(appConfig.dialogue.file),
        dashaPackages: packagesConfig === null || packagesConfig === void 0 ? void 0 : packagesConfig.packagesFolderPath,
        phrasemap: resolveConfigPath(appConfig.nlg.file),
        signatureFile: appConfig.nlg.signatureFile === undefined
            ? undefined
            : resolveConfigPath(appConfig.nlg.signatureFile),
        dataset: ((_a = appConfig.nlu.customIntents) === null || _a === void 0 ? void 0 : _a.file) === undefined
            ? undefined
            : resolveConfigPath((_b = appConfig.nlu.customIntents) === null || _b === void 0 ? void 0 : _b.file),
    };
    /** collect dependent dsl files recursively */
    const dslFilePathsAbs = await collectDslFilePaths(appFilePathsAbs.mainDsl);
    const dslRootFolder = await getRootFolder(dslFilePathsAbs);
    const createDslArchivePath = (p) => {
        p = path_1.default.join("__dsl_dialogue", path_1.default.relative(dslRootFolder, p));
        return p.split(path_1.default.sep).join(path_1.default.posix.sep);
    };
    const createArchivePath = (p) => {
        p = path_1.default.relative(path_1.default.resolve(appFolderPath), p);
        return p.split(path_1.default.sep).join(path_1.default.posix.sep);
    };
    const addDslToArchive = async (p) => {
        const pathInArchive = createDslArchivePath(p);
        const content = await fs_1.default.promises.readFile(p, "utf8");
        archiveData[pathInArchive] = content;
    };
    const addFileToArchive = async (p) => {
        const pathInArchive = createArchivePath(p);
        const content = await fs_1.default.promises.readFile(p, "utf8");
        archiveData[pathInArchive] = content;
    };
    /** add used files to zip */
    const archiveData = {};
    for (const p of dslFilePathsAbs)
        await addDslToArchive(p);
    const restAppFiles = [appFilePathsAbs.phrasemap];
    if (appFilePathsAbs.signatureFile !== undefined)
        restAppFiles.push(appFilePathsAbs.signatureFile);
    if (appFilePathsAbs.dataset !== undefined)
        restAppFiles.push(appFilePathsAbs.dataset);
    for (const p of restAppFiles)
        await addFileToArchive(p);
    /** add dasha packages to zip */
    if (packagesConfig !== undefined) {
        const packageNameToPath = await resolvePackagesPaths(appFolderPath, packagesConfig);
        for (const packageName of Object.keys(packageNameToPath)) {
            const packageAbsPath = packageNameToPath[packageName];
            const filterAsync = async (array, predicate) => {
                const predicateValues = await Promise.all(array.map(predicate));
                return array.filter((_, index) => predicateValues[index] === true);
            };
            const isFilePredicate = async (f) => {
                return (await fs_1.default.promises.lstat(f)).isFile();
            };
            const packageFilePaths = await filterAsync(await findFilesInDir(packageAbsPath, true), isFilePredicate);
            for (const packageFilePath of packageFilePaths)
                await addFileToArchive(packageFilePath);
        }
        await addFileToArchive(packagesConfigFilePathAbs);
    }
    /** substitute dsl entry point */
    appConfig.dialogue.file = createDslArchivePath(appFilePathsAbs.mainDsl);
    /** add fixed config to zip */
    archiveData[path_1.default.relative(path_1.default.resolve(appFolderPath), dashaappFilePathAbs)] =
        JSON.stringify(appConfig);
    return archiveData;
}
//# sourceMappingURL=zip-helpers.js.map