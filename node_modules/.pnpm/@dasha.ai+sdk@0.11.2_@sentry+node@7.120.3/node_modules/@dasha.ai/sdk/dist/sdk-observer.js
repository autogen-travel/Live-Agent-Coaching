"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkObserver = void 0;
const uuid = __importStar(require("uuid"));
const lodash_1 = __importDefault(require("lodash"));
const axios_1 = __importDefault(require("axios"));
const circular_buffer_1 = require("./circular-buffer");
const log_1 = require("./log");
const http_server_1 = require("./http-server");
const errors = __importStar(require("./errors"));
const rest = __importStar(require("./rest-api"));
const transcription_1 = require("./transcription");
const isObject = (x) => typeof x === "object" && x !== null;
var ConversationStatus = rest.models.core.TaskStatus;
/** @internal */ class SdkObserver {
    static initialize(port, maxConversationCount) {
        SdkObserver.shared = new SdkObserver(port, maxConversationCount);
    }
    constructor(port, maxConversationCount) {
        /** implemented as arrow function to avoid issues with 'this' keyword in circular buffer */
        this._removeConversation = (jobId) => {
            this._log.debug(`Removing conversation '${jobId}'`);
            const appId = this._jobIdToAppId[jobId];
            delete this._appIdToAppData[appId][jobId];
            delete this._jobIdToAppId[jobId];
        };
        this.maxConversationCount = maxConversationCount;
        this._conversationCircularBuffer = new circular_buffer_1.CircularBuffer(maxConversationCount, this._removeConversation);
        this._appIdToDeployedApp = {};
        this._appIdToAppData = {};
        this._jobIdToAppId = {};
        this._log = log_1.log.child({ label: `dasha-sdk-observer` });
        this._log.debug(`Starting SDK http observer with max cached conversations count ${maxConversationCount} at port ${port}...`);
        this._server = new SdkHttpApi(this, this._log);
        this._server.listen(port, () => {
            this._log.debug(`SDK http observer is running at http://localhost:${port}`);
        });
    }
    _registerApplication(application) {
        this._log.debug(`Registrating app ${application.applicationId}`);
        const appId = application.applicationId;
        this._appIdToDeployedApp[appId] = application;
        this._appIdToAppData[appId] = {};
        const handleApplicationDispose = () => {
            this._log.debug(`Unsubscribing from application ${application.applicationId}`);
            unsubscribeFromApplication(application);
            this._removeApp(appId);
        };
        const handleJobFailed = (jobId, jobKey, jobData) => {
            this._registerOrUpdateConversation(appId, jobId, ConversationStatus.Failed, jobData);
        };
        const handleJobRejected = (jobId, jobKey, jobData) => {
            this._registerOrUpdateConversation(appId, jobId, ConversationStatus.Rejected, jobData);
        };
        const handleJobTimedOut = (jobId, jobKey) => {
            this._registerOrUpdateConversation(appId, jobId, ConversationStatus.TimedOut);
        };
        const handleJobStarting = (jobId, jobKey, jobData) => {
            this._registerOrUpdateConversation(appId, jobId, ConversationStatus.Starting);
        };
        const handleSingleConvCreated = (conv) => {
            this._subscribeOnConversation(conv);
        };
        const handleQueueReady = (key, conv, info) => {
            this._subscribeOnConversation(conv);
        };
        const handleQueuePushConversation = (jobId) => {
            this._registerOrUpdateConversation(appId, jobId, ConversationStatus.Unspecified);
        };
        const unsubscribeFromApplication = (application) => {
            application.off("_disposed", handleApplicationDispose);
            application.off("unableToReconnect", handleApplicationDispose);
            application.off("error", handleApplicationDispose);
            application.off("_jobFailed", handleJobFailed);
            application.off("_jobRejected", handleJobRejected);
            application.off("_jobTimedOut", handleJobTimedOut);
            application.off("_jobStarting", handleJobStarting);
            application.off("_singleConversationCreated", handleSingleConvCreated);
            application.queue.off("ready", handleQueueReady);
            application.queue.off("_conversationPushed", handleQueuePushConversation);
        };
        application.on("_disposed", handleApplicationDispose);
        application.on("unableToReconnect", handleApplicationDispose);
        application.on("error", handleApplicationDispose);
        application.on("_jobFailed", handleJobFailed);
        application.on("_jobRejected", handleJobRejected);
        application.on("_jobTimedOut", handleJobTimedOut);
        application.on("_jobStarting", handleJobStarting);
        application.on("_singleConversationCreated", handleSingleConvCreated);
        application.queue.on("ready", handleQueueReady);
        application.queue.on("_conversationPushed", handleQueuePushConversation);
    }
    _getApplications() {
        return Object.values(this._appIdToDeployedApp);
    }
    _getApplication(applicationId) {
        return this._appIdToDeployedApp[applicationId];
    }
    _tryRegisterConversation(applicationId, jobId, input) {
        if (this._appIdToAppData[applicationId] === undefined)
            throw new errors.SdkObserverError(`Application '${applicationId}' not found`);
        this._registerOrUpdateConversation(applicationId, jobId, ConversationStatus.Unspecified, undefined, undefined, input);
    }
    _tryFindSingleApplication() {
        const deployedApps = this._getApplications();
        if (deployedApps.length === 0) {
            throw new errors.SdkObserverError("No applications are deployed yet.");
        }
        if (deployedApps.length > 1) {
            throw new errors.SdkObserverError(`There are several deployed applications, please provide 'applicationId' parameter. ` +
                `Current applications: [${deployedApps.map((a) => a.applicationId).join(", ")}].`);
        }
        return deployedApps[0];
    }
    _getConversationDataFromCache(jobId) {
        const applicationId = this._jobIdToAppId[jobId];
        if (applicationId === undefined)
            return undefined;
        const convData = this._appIdToAppData[applicationId][jobId];
        if (convData === undefined)
            return undefined;
        return { applicationId, jobId, ...convData };
    }
    async _tryLoadConversationData(jobId, account) {
        const sessionLogEntity = await tryLoadSessionLogEntity(jobId, account, this._log);
        const app = this._getApplication(sessionLogEntity.applicationId);
        if (app === undefined) {
            throw new errors.SdkObserverError(`Could not find deployed application for provided jobId '${jobId}'.`);
        }
        let input;
        let output;
        let errorMsg;
        const transcription = [];
        try {
            const debugLog = await _tryLoadSessionDebugLog(jobId, account, this._log);
            const transcriptionParser = new transcription_1.TranscriptionParser();
            transcriptionParser.on("transcription", (t) => {
                transcription.push(t);
            });
            for (const jobEvent of debugLog) {
                input = input !== null && input !== void 0 ? input : parseInputData(jobEvent);
                output = output !== null && output !== void 0 ? output : parseOutputData(jobEvent);
                errorMsg = errorMsg !== null && errorMsg !== void 0 ? errorMsg : parseFunctionError(jobEvent);
                transcriptionParser.push(jobEvent);
            }
        }
        catch (e) {
            this._log.debug(`Could not load session debug log for jobId '${jobId}'`);
        }
        const recordingUrl = app._getRecordingUrl(jobId);
        let conversationData;
        switch (sessionLogEntity.status) {
            case ConversationStatus.Completed:
                conversationData = {
                    status: sessionLogEntity.status,
                    result: {
                        output: output,
                        transcription: transcription,
                        recordingUrl: (await checkFileExist(recordingUrl)) ? recordingUrl : undefined,
                        startTime: getStartTime(sessionLogEntity.completedTime, sessionLogEntity.duration),
                        endTime: new Date(sessionLogEntity.completedTime),
                    },
                    input: input,
                };
                break;
            case ConversationStatus.Failed:
                conversationData = {
                    status: sessionLogEntity.status,
                    result: { error: errorMsg !== null && errorMsg !== void 0 ? errorMsg : "unknown" },
                    input: input,
                };
                break;
            case ConversationStatus.Rejected:
            case ConversationStatus.TimedOut:
            case ConversationStatus.Starting:
            case ConversationStatus.Running:
            case ConversationStatus.Unspecified:
            default:
                conversationData = {
                    status: sessionLogEntity.status,
                    result: undefined,
                    input: undefined,
                };
                break;
        }
        return {
            applicationId: sessionLogEntity.applicationId,
            jobId: sessionLogEntity.id,
            ...conversationData,
        };
    }
    async _tryGetConversationData(jobId, account) {
        const conv = this._getConversationDataFromCache(jobId);
        if (conv === undefined) {
            this._log.debug(`Could not get conversation from observer cache. Trying to load it from server...`);
            return await this._tryLoadConversationData(jobId, account);
        }
        this._log.debug(`Got conversation from cache.`);
        return conv;
    }
    _getConversationsDataFromCache() {
        return this._conversationCircularBuffer
            .toArray()
            .map((jobId) => this._getConversationDataFromCache(jobId));
    }
    _subscribeOnConversation(conv) {
        const handleConversationStarting = (applicationId, jobId, input) => {
            this._registerOrUpdateConversation(applicationId, jobId, ConversationStatus.Starting, undefined, undefined, input);
        };
        const handleConversationExecuted = (jobId, result) => {
            const appId = this._jobIdToAppId[jobId];
            if (appId === undefined)
                return;
            this._registerOrUpdateConversation(appId, jobId, ConversationStatus.Completed, undefined, result);
            unsubscribe(conv);
        };
        const unsubscribe = (conv) => {
            conv.off("_conversationStarting", handleConversationStarting);
            conv.off("_conversationCompleted", handleConversationExecuted);
            this._log.debug(`Unsubscribed from conversation ${conv._jobId}`);
        };
        conv.on("_conversationStarting", handleConversationStarting);
        conv.on("_conversationCompleted", handleConversationExecuted);
    }
    _registerOrUpdateConversation(appId, jobId, convStatus, eventData, result, convInput) {
        var _a, _b, _c;
        var _d, _e, _f;
        this._log.debug(`Trying to register or update conversation ${JSON.stringify({
            appId,
            jobId,
            convStatus,
            eventData,
            result,
            convInput,
        })}...`);
        /** Note: if buffer is full, then this._removeConversation(evictedConversationId) will be executed */
        if (this._jobIdToAppId[jobId] === undefined) {
            this._log.debug(`Pushing jobId '${jobId}' to cbuffer`);
            const result = this._conversationCircularBuffer.pushFront(jobId);
            if (result === false) {
                this._log.debug(`Could not push to cbuffer, exiting registration.`);
                return;
            }
        }
        (_a = (_d = this._jobIdToAppId)[jobId]) !== null && _a !== void 0 ? _a : (_d[jobId] = appId);
        (_b = (_e = this._appIdToAppData[appId])[jobId]) !== null && _b !== void 0 ? _b : (_e[jobId] = {
            result: undefined,
            input: undefined,
            status: ConversationStatus.Unspecified,
        });
        (_c = (_f = this._appIdToAppData[appId][jobId]).input) !== null && _c !== void 0 ? _c : (_f.input = convInput);
        this._appIdToAppData[appId][jobId].status = convStatus;
        switch (convStatus) {
            case ConversationStatus.Unspecified:
            case ConversationStatus.Starting:
            case ConversationStatus.TimedOut:
                break;
            case ConversationStatus.Completed:
                this._appIdToAppData[appId][jobId].result = result;
                break;
            case ConversationStatus.Failed:
                if (eventData === undefined) {
                    eventData = { msg: "unknown" };
                }
                this._appIdToAppData[appId][jobId].result = {
                    error: new errors.ConversationError(eventData).message,
                };
                break;
            case ConversationStatus.Rejected:
                if (eventData === undefined) {
                    eventData = { reason: "unknown" };
                }
                this._appIdToAppData[appId][jobId].result = {
                    error: new errors.ConversationRejectedError(eventData, jobId, "").message,
                };
                break;
            default:
                break;
        }
        this._log.debug(`Registered: ${JSON.stringify(this._appIdToAppData[appId][jobId])}`);
    }
    _removeApp(applicationId) {
        /** remove jobIds of removing appication from circular buffer */
        const jobIdsToRemove = Object.keys(this._appIdToAppData[applicationId]);
        jobIdsToRemove.forEach((jobId) => this._removeConversation(jobId));
        const newCBufferData = lodash_1.default.difference(this._conversationCircularBuffer.toArray(), jobIdsToRemove);
        this._conversationCircularBuffer.resetData(newCBufferData);
        delete this._appIdToDeployedApp[applicationId];
        delete this._appIdToAppData[applicationId];
    }
}
exports.SdkObserver = SdkObserver;
class SdkHttpApi extends http_server_1.HttpServer {
    constructor(observer, log) {
        var _a, _b, _c, _d;
        super(log.child({}));
        this._methodHandlers = {
            GET: {
                "/health": async (req, res) => {
                    res.writeHead(200).end("Server is alive");
                },
                "/api-description": async (req, res) => {
                    res.writeHead(200).end(this.getApiDescription());
                },
                "/deployed-applications": async (req, res) => {
                    const apps = this._observer._getApplications();
                    return res.writeHead(200).end(JSON.stringify(apps.map((a) => {
                        return {
                            groupId: a.groupId,
                            applicationId: a.applicationId,
                            applicationName: a.applicationName,
                            inputSchema: a.inputSchema,
                            outputSchema: a.outputSchema,
                        };
                    })));
                },
                "/conversation": async (req, res) => {
                    const { account } = await this.tryAuthorize(req);
                    const params = (0, http_server_1.readGetSearchParams)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    const { jobId } = params;
                    if (jobId === undefined) {
                        throw new errors.SdkObserverError(`Please, provide 'jobId'`);
                    }
                    const conv = await this._observer._tryGetConversationData(jobId, account);
                    return res.writeHead(200).end(JSON.stringify(conv));
                },
                "/conversation/result": async (req, res) => {
                    const { account } = await this.tryAuthorize(req);
                    const params = (0, http_server_1.readGetSearchParams)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    const { jobId } = params;
                    if (jobId === undefined) {
                        throw new errors.SdkObserverError(`Please, provide 'jobId'`);
                    }
                    const conv = await this._observer._tryGetConversationData(jobId, account);
                    if (conv.result === undefined) {
                        return res.writeHead(404).end(`Conversation result does not exist yet`);
                    }
                    return res.writeHead(200).end(JSON.stringify(conv.result));
                },
                "/conversation/input": async (req, res) => {
                    const { account } = await this.tryAuthorize(req);
                    const params = (0, http_server_1.readGetSearchParams)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    const { jobId } = params;
                    if (jobId === undefined) {
                        throw new errors.SdkObserverError(`Please, provide 'jobId'`);
                    }
                    const conv = await this._observer._tryGetConversationData(jobId, account);
                    if (conv.input === undefined) {
                        return res.writeHead(404).end(`Conversation input does not exist yet`);
                    }
                    return res.writeHead(200).end(JSON.stringify(conv.input));
                },
                "/conversation/status": async (req, res) => {
                    const { account } = await this.tryAuthorize(req);
                    const params = (0, http_server_1.readGetSearchParams)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    const { jobId } = params;
                    if (jobId === undefined) {
                        throw new errors.SdkObserverError(`Please, provide 'jobId'`);
                    }
                    const conv = await this._observer._tryGetConversationData(jobId, account);
                    return res.writeHead(200).end(JSON.stringify(conv.status));
                },
                "/conversations": async (req, res) => {
                    await this.tryAuthorize(req);
                    const conversations = this._observer
                        ._getConversationsDataFromCache()
                        .filter((el) => el !== undefined);
                    return res.writeHead(200).end(JSON.stringify(conversations));
                },
                "/conversations/statuses": async (req, res) => {
                    await this.tryAuthorize(req);
                    const conversations = this._observer
                        ._getConversationsDataFromCache()
                        .filter((el) => el !== undefined)
                        .map(({ applicationId, jobId, status }) => {
                        return { applicationId, jobId, status };
                    });
                    return res.writeHead(200).end(JSON.stringify(conversations));
                },
                "/conversations/inputs": async (req, res) => {
                    await this.tryAuthorize(req);
                    const conversations = this._observer
                        ._getConversationsDataFromCache()
                        .filter((el) => el !== undefined)
                        .map(({ applicationId, jobId, input }) => {
                        return { applicationId, jobId, input };
                    });
                    return res.writeHead(200).end(JSON.stringify(conversations));
                },
                "/conversations/results": async (req, res) => {
                    await this.tryAuthorize(req);
                    const conversations = this._observer
                        ._getConversationsDataFromCache()
                        .filter((el) => el !== undefined)
                        .map(({ applicationId, jobId, result }) => {
                        return { applicationId, jobId, result };
                    });
                    return res.writeHead(200).end(JSON.stringify(conversations));
                },
            },
            POST: {
                "/application/start": async (req, res) => {
                    await this.tryAuthorize(req);
                    const params = await (0, http_server_1.readPostParamsJson)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    let applicationId = params.applicationId;
                    const concurrency = params.concurrency;
                    if (applicationId === undefined) {
                        this._log.debug(`Application id is not provided, trying to find single deployed application.`);
                        applicationId = this._observer._tryFindSingleApplication().applicationId;
                    }
                    const app = this._observer._getApplication(applicationId);
                    if (app === undefined) {
                        return res.writeHead(404).end(`Could not find application '${applicationId}'`);
                    }
                    await app.start({ concurrency });
                    return res.writeHead(200).end(`Application started`);
                },
                "/application/stop": async (req, res) => {
                    await this.tryAuthorize(req);
                    const params = await (0, http_server_1.readPostParamsJson)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    let applicationId = params.applicationId;
                    if (applicationId === undefined) {
                        this._log.debug(`Application id is not provided, trying to find single deployed application.`);
                        applicationId = this._observer._tryFindSingleApplication().applicationId;
                    }
                    const app = this._observer._getApplication(applicationId);
                    if (app === undefined) {
                        return res.writeHead(404).end(`Could not find application '${applicationId}'`);
                    }
                    await app.stop();
                    return res.writeHead(200).end(`Application stopped`);
                },
                "/application/dispose": async (req, res) => {
                    await this.tryAuthorize(req);
                    const params = await (0, http_server_1.readPostParamsJson)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    let applicationId = params.applicationId;
                    if (applicationId === undefined) {
                        this._log.debug(`Application id is not provided, trying to find single deployed application.`);
                        applicationId = this._observer._tryFindSingleApplication().applicationId;
                    }
                    const app = this._observer._getApplication(applicationId);
                    if (app === undefined) {
                        return res.writeHead(404).end(`Could not find application '${applicationId}'`);
                    }
                    app.dispose();
                    return res.writeHead(200).end(`Application disposed`);
                },
                "/conversation": async (req, res) => {
                    await this.tryAuthorize(req);
                    const params = await (0, http_server_1.readPostParamsJson)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    let applicationId = params.applicationId;
                    const conversationData = params.conversationData;
                    if (conversationData === undefined) {
                        return res.writeHead(400).end(`Please, provide conversation data.`);
                    }
                    const { options, input } = conversationData;
                    let app;
                    if (applicationId === undefined) {
                        this._log.debug(`Application id is not provided, trying to find single deployed application...`);
                        app = this._observer._tryFindSingleApplication();
                    }
                    else {
                        app = this._observer._getApplication(applicationId);
                        if (app === undefined) {
                            throw new errors.SdkObserverError(`Could not find application by applicationId '${applicationId}'`);
                        }
                    }
                    applicationId = app.applicationId;
                    options.input = input;
                    const { jobId } = await app.queue.push("__posted_conversation:" + uuid.v4(), options);
                    this._observer._tryRegisterConversation(applicationId, jobId, input);
                    return res.writeHead(200).end(JSON.stringify({ applicationId, jobId }), "utf8");
                },
                "/conversations": async (req, res) => {
                    await this.tryAuthorize(req);
                    const params = await (0, http_server_1.readPostParamsJson)(req);
                    this._log.debug(`Params: ${JSON.stringify(params)}`);
                    let applicationId = params.applicationId;
                    const conversationsData = params.conversationsData;
                    if (conversationsData === undefined) {
                        return res.writeHead(400).end(`Please, provide parameter 'conversationsData'.`);
                    }
                    if (!Array.isArray(conversationsData)) {
                        return res.writeHead(400).end(`Parameter 'conversationsData' must be array.`);
                    }
                    let app;
                    if (applicationId === undefined) {
                        this._log.debug(`Application id is not provided, trying to find single deployed application...`);
                        app = this._observer._tryFindSingleApplication();
                    }
                    else {
                        app = this._observer._getApplication(applicationId);
                        if (app === undefined)
                            throw new errors.SdkObserverError(`Could not find application by applicationId '${applicationId}'`);
                    }
                    applicationId = app.applicationId;
                    const result = [];
                    for (const conversationData of conversationsData) {
                        const { options, input } = conversationData;
                        options.input = input;
                        const { jobId } = await app.queue.push("__posted_conversation:" + uuid.v4(), options);
                        this._observer._tryRegisterConversation(applicationId, jobId, input);
                        result.push({ applicationId, jobId });
                    }
                    return res.writeHead(200).end(JSON.stringify(result), "utf8");
                },
            },
        };
        this._observer = observer;
        this.allowCors = true;
        const methodDescriptions = {
            GET: {
                "/health": `Returns "Ok" if server is alive.`,
                "/api-description": `Get API description.`,
                "/deployed-applications": "Get list of deployed applications.",
                "/conversation": `Get data for particular conversation. Requires authorization.
          params: {
            jobId: string - id of conversation job
          }`,
                "/conversation/result": `Get result for particular conversation. Requires authorization.
          params: {
            jobId: string - id of conversation job
          }`,
                "/conversation/input": `Get input for particular conversation. Requires authorization.
          params: {
            jobId: string - id of conversation job
          }`,
                "/conversation/status": `Get status for particular conversation. Requires authorization.
          params: {
            jobId: string - id of conversation job
          }`,
                "/conversations": `Get all cached conversations. Requires authorization.`,
                "/conversations/statuses": `Get all cached conversations statuses. Requires authorization.`,
                "/conversations/inputs": `Get all cached conversations inputs. Requires authorization.`,
                "/conversations/results": `Get all cached conversations inputs. Requires authorization.`,
            },
            POST: {
                "/application/start": `Start particular application. Requires authorization.
          params: {
            applicationId: string - (optional)
          }`,
                "/application/stop": `Stop particular application. Requires authorization.
          params:{
            applicationId: string - (optional)
          }`,
                "/application/dispose": `Dispose partiular application. Requires authorization.
          params: {
            applicationId: string - (optional)
        }`,
                "/conversation": `Enqueue conversation. Requires authorization.
          params: {
          applicationId (optional)
          conversationData: {
              pushOptions? object - (optional) queue push options
              input: object - (optional) conversation input
          }
        }`,
                "/conversations": `Enqueue array of conversations. Requires authorization.
          params: {
            applicationId: (optional) string - 
            conversationsData: {
              pushOptions: object - (optional) queue push options
              input: object - (optional) conversation input
            }[] - array of conversation data to push
          }`,
            },
        };
        /** set get methods */
        for (const methodName of Object.keys(methodDescriptions.GET)) {
            this.get(methodName, (_a = this._methodHandlers.GET[methodName]) !== null && _a !== void 0 ? _a : notImplementedHandler, (_b = methodDescriptions.GET[methodName]) !== null && _b !== void 0 ? _b : "---");
        }
        /** set post methods */
        for (const methodName of Object.keys(methodDescriptions.POST)) {
            this.post(methodName, (_c = this._methodHandlers.POST[methodName]) !== null && _c !== void 0 ? _c : notImplementedHandler, (_d = methodDescriptions.POST[methodName]) !== null && _d !== void 0 ? _d : "---");
        }
    }
    async tryAuthorize(req) {
        const observer = SdkObserver.shared;
        if (observer === undefined) {
            throw new errors.SdkObserverError(`Sdk observer is not initialized`);
        }
        this._log.debug("Authorizing...");
        const authHeader = req.headers.authorization;
        const exampleHeader = "example: { authorization: 'Bearer <your-Dasha-apikey>' }";
        if (authHeader === undefined) {
            throw new errors.SdkObserverError(`Request does not contain header 'authorization', ${exampleHeader}`);
        }
        if (typeof authHeader !== "string") {
            throw new errors.SdkObserverError(`Request header 'authorization' is not a string, ${exampleHeader}`);
        }
        const apiKey = authHeader.replace("Bearer ", "");
        const apps = observer._getApplications();
        this._log.debug(`Trying to find customer for provided token...`);
        let userCustomerId;
        let userAccount;
        for (const app of apps) {
            try {
                const account = app.account;
                account.apiKey = apiKey;
                const customerApi = new rest.CustomerApi(account, this._log);
                userCustomerId = (await customerApi.getMe()).id;
                if (userCustomerId !== app.customerId) {
                    continue;
                }
                this._log.debug(`Found customer '${userCustomerId}'`);
                userAccount = account;
                break;
            }
            catch (e) {
                this._log.debug(`Could authorize with applicationId ${JSON.stringify(app.applicationId)}`);
            }
        }
        if (userCustomerId === undefined) {
            throw new errors.SdkObserverError(`Could not find customer for provided token.`);
        }
        this._log.debug(`Checking if customer corresponds to any deployed application...`);
        const foundApp = apps.find((app) => app.customerId === userCustomerId);
        if (foundApp === undefined) {
            throw new errors.SdkObserverError(`Provided token does not correspond to customer of any application deployed in current process`);
        }
        this._log.debug(`Successfully authorized with deployed application, applicationId: '${foundApp.applicationId}'`);
        return { customerId: userCustomerId, account: userAccount };
    }
}
const notImplementedHandler = (req, res) => {
    res.writeHead(501);
    return res.end("Method is not implemented yet");
};
function getStartTime(completedStr, durationStr) {
    durationStr = "1970-01-01T" + durationStr + "+00:00";
    const completed = new Date(completedStr);
    const duration = new Date(durationStr);
    const started = completed.valueOf() - duration.valueOf();
    return new Date(started);
}
async function checkFileExist(url) {
    return axios_1.default
        .get(url, {
        responseType: "stream",
    })
        .then((response) => {
        return response.status === 200;
    })
        .catch((error) => {
        return false;
    });
}
async function tryLoadSessionLogEntity(jobId, account, log) {
    const sessionLogApi = new rest.SessionLogApi(account, log);
    return await sessionLogApi.getSessionEntity(jobId);
}
async function _tryLoadSessionDebugLog(jobId, account, log) {
    const sessionLogApi = new rest.SessionLogApi(account, log);
    return await sessionLogApi.getSessionDebugLog(jobId);
}
function parseInputData(jobEvent) {
    const { msg } = jobEvent;
    if (!isObject(msg))
        return undefined;
    if (msg.msgId !== "JobDataMessage")
        return undefined;
    return msg.inputData;
}
function parseOutputData(jobEvent) {
    const { msg } = jobEvent;
    if (!isObject(msg))
        return undefined;
    if (msg.msgId !== "JobDataMessage")
        return undefined;
    return msg.outputData;
}
function parseFunctionError(jobEvent) {
    const { msg } = jobEvent;
    if (!isObject(msg))
        return undefined;
    if (msg.msgId !== "JobCommunicationMessage")
        return undefined;
    const content = msg.content;
    if (!isObject(content))
        return undefined;
    if (content.type !== "error")
        return undefined;
    return content.message;
}
//# sourceMappingURL=sdk-observer.js.map