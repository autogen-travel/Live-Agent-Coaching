"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircularBuffer = void 0;
class CircularBuffer {
    constructor(capacity, evictedCallback) {
        this._capacity = capacity;
        this._size = 0;
        this._leftIdx = 0;
        this._rightIdx = 0;
        this._data = new Array(capacity);
        const emptycb = (element) => { };
        this._evictedCallback = evictedCallback !== null && evictedCallback !== void 0 ? evictedCallback : emptycb;
    }
    capacity() {
        return this._capacity;
    }
    size() {
        return this._size;
    }
    isEmpty() {
        return this._size == 0;
    }
    isFull() {
        return this._size == this._capacity;
    }
    pushFront(element) {
        if (this._capacity === 0)
            return false;
        const evictedElement = this._data[this._rightIdx];
        if (evictedElement !== undefined) {
            this._evictedCallback(evictedElement);
        }
        this._data[this._rightIdx] = element;
        this._rightIdx = this.increaseIdx(this._rightIdx);
        if (this.isFull()) {
            this._leftIdx = this.increaseIdx(this._leftIdx);
        }
        else {
            ++this._size;
        }
        return true;
    }
    toArray() {
        if (this.isEmpty())
            return [];
        if (this._leftIdx < this._rightIdx) {
            return this._data.slice(this._leftIdx, this._rightIdx);
        }
        return this._data.slice(this._leftIdx).concat(this._data.slice(0, this._rightIdx));
    }
    data() {
        const buffer = new Array(this._capacity);
        this._data.forEach((item, index) => buffer[index] = item);
        return buffer;
    }
    /**
     * Resets currently stored data with provided array, regarding to current capacity.
     * Note: current capacity will not be changed
     * Note: all previous data will be erased, but the 'evictedCallback()' function will not be called for erased items
     * @param newData new data to store
     * @param pushFrontLike if true, the data will be set in the same order as it would be pushed by @method pushFront,
     *    otherwise, the data will be pushed as it would be done by @method pushBack
     */
    resetData(newData, pushFrontLike = true) {
        if (newData.length > this._capacity) {
            /** cut out the elements that are going to be pushed out  */
            newData = newData.slice(newData.length - this._capacity);
        }
        if (pushFrontLike === false)
            newData = [...newData].reverse();
        this._size = newData.length;
        this._leftIdx = 0;
        this._rightIdx = newData.length % this._capacity;
        this._data = newData;
        if (this._data.length < this._capacity) {
            this._data.length = this._capacity;
        }
    }
    increaseIdx(idx) {
        return (idx + 1) % this._capacity;
    }
}
exports.CircularBuffer = CircularBuffer;
//# sourceMappingURL=circular-buffer.js.map