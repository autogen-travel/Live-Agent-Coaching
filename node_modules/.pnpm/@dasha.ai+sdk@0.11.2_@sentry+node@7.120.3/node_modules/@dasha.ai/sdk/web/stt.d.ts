import { Conversation } from "./conversation";
/**
 * A speech-to-text provider to use for an application.
 *
 * `"default"` is a default STT engine.
 *
 * `"dasha"` is Dasha.AI's own STT engine.
 *
 * `"disabled"` disables STT altogether; useful for building IVRs
 *
 * @see {@link Application.sttDispatcher}
 */
export type SttProviderName = "default" | "dasha" | "disabled" | TinkoffSTT | GoogleStt | MicrosoftStt | YandexStt | DeepgramSTT;
/**
 * Deepgram stt setting
 * @see {@link https://developers.deepgram.com/reference/streaming}
 */
export interface DeepgramSTT {
    type: "Deepgram";
    credentials?: {
        apiKey: string;
        apiUrl?: string;
        requireSSL?: boolean;
    };
    settings: {
        model: string;
        version?: string;
        language?: string;
        tier?: string;
        punctuate?: boolean;
        profanityFilter?: boolean;
        redaction?: string[];
        numerals?: boolean;
        numbers?: boolean;
        numbersSpaces?: boolean;
        dates?: boolean;
        dateFormat?: string;
        times?: boolean;
        measurements?: boolean;
        smartFormat?: boolean;
        replace?: string[];
        keywords?: string[];
        keywordBoost?: string;
        endpointing?: string;
        fillerWords?: boolean;
        tag?: string[];
    };
}
export interface TinkoffSTT {
    type: "Tinkoff";
    credentials?: {
        issuer: string;
        subject: string;
        audience: string;
        signatureAlgorithm: string;
        apiKey: string;
        secretKey: string;
        serviceHost?: string;
    };
    settings: {
        languageCode?: string;
        profanityFilter?: boolean;
        model?: string;
        enableDenormalization?: boolean;
        enableAutomaticPunctuation?: boolean;
        speechContexts?: {
            phrases: {
                text: string;
                score?: number;
            }[];
        }[];
    };
}
export interface MicrosoftStt {
    type: "Microsoft";
    credentials?: {
        subscriptionKey: string;
        region: string;
    };
    settings: {
        languageCode: string;
        enableDictation?: boolean;
        endpointId?: string;
        profanity?: "Masked" | "Removed" | "Raw";
    };
}
export interface YandexStt {
    type: "Yandex";
    credentials?: {
        serviceHost?: string;
        folderId: string;
    } & ({
        type: string;
        tokenUri: string;
        signatureAlgorithm: string;
        privateKey: string;
        privateKeyId: string;
        serviceAccountId: string;
    } | {
        apiKey: string;
    } | {
        IamToken: string;
    });
    settings: {
        version: "v2";
        profanityFilter?: boolean;
        model: string;
        languageCode: string;
        literatureText?: boolean;
        enableNormalization?: boolean;
    } | {
        version: "v3";
        model: string;
        textNormalization?: {
            textNormalization?: "TEXT_NORMALIZATION_ENABLED" | "TEXT_NORMALIZATION_DISABLED";
            profanityFilter?: boolean;
            literatureText?: boolean;
        };
        languageRestriction?: {
            restrictionType?: "WHITELIST" | "BLACKLIST ";
            languageCode: string[];
        };
    };
}
export interface GoogleStt {
    type: "Google";
    credentials?: {
        type: string;
        projectId: string;
        privateKeyId: string;
        privateKey: string;
        clientEmail: string;
        clientId: string;
        authUri: string;
        tokenUri: string;
        authProvider_x509_certUrl: string;
        client_x509_certUrl: string;
    };
    settings: {
        languageCode: string;
        model?: string;
        adaptation?: {
            phraseSetReferences?: string[];
            phraseSetReferencesAsPhraseSetNames?: {
                projectId: string;
                locationId: string;
                phraseSetId: string;
            }[];
            phraseSets?: {
                boost?: number;
                name: string;
                phrases: {
                    boost?: number;
                    value: string;
                }[];
                phraseSetName: {
                    projectId: string;
                    locationId: string;
                    phraseSetId: string;
                };
            }[];
            customClasses?: {
                name: string;
                customClassId: string;
                customClassName: {
                    projectId: string;
                    locationId: string;
                    customClassId: string;
                };
                items: {
                    value: string;
                }[];
            }[];
        };
        alternativeLanguageCodes?: string[];
        enableAutomaticPunctuation?: boolean;
        speechContexts?: {
            boost?: number;
            phrases: string[];
        }[];
        useEnhanced?: boolean;
        profanityFilter?: boolean;
    };
}
/**
 * A callback that selects a speech-to-text engine for the conversations.
 *
 * @see {@link Application.sttDispatcher}
 *
 * @deprecated use {@link Conversation.audio.stt} instead
 */
export type SttDispatcher<TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>> = (conv: Conversation<TInput, TOutput>) => SttProviderName | Promise<SttProviderName>;
